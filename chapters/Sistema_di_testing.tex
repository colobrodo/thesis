\chapter{Sistema di Testing}
    \section{Meccanismo dell'oracolo\label{oracolo}}
        Nel flusso di sviluppo attuale vi è una fase di test di integrazione.
        Per la verifica del test viene sfruttato il meccanismo dell’oracolo.
        Esso consiste in accoppiare ogni test all'output aspettato (chiamato appunto oracolo),
        e successivamente effettuare un confronto tra il risultato del test e il suo riferimento.
        Il test viene dichiarato fallimentare se ci sono differenze tra questi outcome.
        
        L'idea è che ogni test rappresenti un caso d'uso, e il software deve mantenere un comportamento 
        consistente con la sua versione precedente.
        Nel caso questo comportamento voglia essere esplicitamente cambiato, viene modificato il test.

        Nel nostro sistema l'output aspettato è salvato in file .reference e il risultato prodotto
        dal test in un file current.
        Il file current viene salvato nel file system solo se effettivamente diverso dal suo riferimento.
        
        Salvare il nuovo stato può consentire allo sviluppatore di confrontare i due file per capire quale sia l'errore introdotto nel software. \newline
        Nella sezione successiva viene illustrato da quali elementi è composto un test e quale sia la loro funzione.
    \section{Anatomia di un test\label{testanatomy}}
        Un test consiste in un insieme di file locati per comodit\'a nella stessa cartella. 

        Ogni test consiste in:
        \begin{itemize}
            \item un file CAD di partenza
            \item dei file per specificare una configurazione cliente
            \item un file scl (linguaggio di scripting proprietario) o un file python
            \item un riferimento (file .reference)
        \end{itemize}
    \section{Ciclo di vita del test}
        Il software, per lanciare un test, importa il file CAD e le configurazioni clienti.
        Successivamente esegue lo script SCL o Python, che con opportune librerie, si interfaccia al software
        e simula le operazioni utente. 
        
        Una volta reminate queste operazioni il test salva il suo stato in un file e lo confronta con la sua reference 
        salvata nella cache del test. 

        Se la reference coincide il file di stato questo, viene eliminato, altrimenti viene salvato.

    \section{Integrazione nel Workflow}
        \subsection{Fase Preliminare di sviluppo}
            I test sono suddivisi in caso d'uso quindi, per la maggior parte dei casi, lo sviluppatore sa quali test controlleranno la correttezza della sua modifica.
            
        \subsection{Server di testing}
            Essendo la test suite molto grossa e il processo di testing molto dispendioso, 
            la sessione di test viene lanciata, non in locale dal singolo sviluppatore, 
            ma le modifiche del software già compilate (sostituendo l’exe o una libreria dinamica .dll) 
            vengono caricate su un server dedicato che eseguirà ogni test della test suite.
            
            
            Anche per questo motivo lo sviluppatore non interagisce sui singoli casi di test da file system,
            ma per elencare i test fallimentari, confrontarli e committare eventuali cambiamenti, usa un report dinamico, 
            proprietario, oggetto di questa tesi.
    \section{Versioning dei tests}
        I test si trovano sotto un sistema di versioning.
        Quando uno sviluppatore decide di cambiare il comportamento in un caso d'uso o aggiungere una funzionalità,
        modificher\'a o creer\'a rispettivamente un test.
        Esso verrà committato nel sistema di versioning in modo che gli altri sviluppatori possano testare il software secondo le nuove specifiche definite dal test.
