\chapter{Backend}
        Il backend è stato sviluppato in \href{https://www.python.org}{Python} usando il framework \href{https://flask.palletsprojects.com/en/1.1.x/}{Flask}.
        \'E stato scelto Python perchè è un linguaggio già usato internamente per lo sviluppo di plugin e tool interni.

        \section{Specifica e documentazione}
            Prima della fase di sviluppo è stata predisposto un periodo di design dell' API.
            Questo processo ha prodotto un file di specifica (descritta nel paragrafo 
            \ref{openapi}).\\\\
            Questa fase preliminare allo sviluppo è durata circa una settimana ed è servita per 
            individuare difficoltà tecniche in modo preliminare che sono sate discusse con il team.
            Risparmiando così tempo in corso di sviluppo, evitando di dover ristrutturare l'applicazione.
            Questa specifica come vedremo in seguito è servita anche a produrre automaticamente una pagina di documentazione (\ref{apidoc}).
                
            \subsection{Specifica in linguaggio OpenAPI\label{openapi}}
                La Specifica dell'API è stata scritta in formato OpenAPI.
                Questo file può essere scritto in linguaggio JSON o YML, io ho scelto il secondo perchè
                sintatticamente più leggero e usa l'indentazione per separare le sezioni, facilitandone dunque la scrittura. 
                Questo formato ci consente di descrivere tutte le chiamate che il server 
                mette a disposizione, specificando:
                \begin{itemize}
                    \item il formato dell'URI 
                    \item il metodo
                    \item il formato di interscampio dei dati (json, xml ecc) 
                    \item la struttura della risposta
                    \item come deve essere strutturata la richiesta perch\'e essa sia valida
                        \item i codici di errori e la loro semantica specifica nel contesto dell'applicazione
                \end{itemize}
                
            \subsection{Documentazione\label{apidoc}}
                Inoltre da questa specifica è possibile generare la documentazione, in pagina statica html,
                tramite l'utilizzo di diverse cli.
                Io ho scelto ReDoc, perchè mette a disposizione diverse vendore-extension, cioè sezioni che
                se specificate provedono una maggiore customizzazione della pagina generata, come sezioni di codici disposizione
                esempio per effettuare una determinata chiamata al server.
                Oppure aggiungere riferimenti a file markdown esterni da includere nella documentazione.
                
            \subsection{Continous integration}
                Il processo di scrittura della documentazione è stato aggiunto a una pipeline di CI
                \footnote{\textbf{Continous Integration} - L'integrazione continua consiste nell'integrare gli ambienti di sviluppo dei diversi sviluppatori tramite processi di build, testing ecc... eseguiti da un server condiviso}.
                Questo processo si occupa, solo se il file .yml di specifica viene modificato, di 
                rigenerare il file html di documentazione.
                Questo file viene successivamente servito in modo da rendere la documentazione 
                disponibile online e sempre aggiornata con le specifiche.

    \section{Tecnologie Utilizzate}  
        \subsection{Python}
            Python \'e un linguaggio di scripting, interpretato ad alto livello, ovvero la gestione della memoria viene effettuata da un sistema di garbage collection e non delegata allo sviluppatore.
            Questo linguaggio è stato scelto siccome \'e usato per lo scripting all'interno di altri applicativi esistenti e dunque gi\'a familiare a molti sviluppatori.
            Tra le varie librerie prodotte \'e presente anche un modulo per lanciare i test e inviare i risultati agli sviluppatori via e-mail.
            Questo modulo non è stato utilizzato all'interno del test report ma l'uso dello stesso linguaggio ha contribuito a mantenere la code-base pi\'u uniforme.
        \subsection{Flask}  
            Flask \'e un \textit{micro}Framework per la creazione di servizi web, esso consente di creare applicazioni complete o API (come nel nostro caso)
            La sua peculiarit\'a \'e la sua minimalit\'a e consente si scrivere applicazioni in modo rapido riducendo al minimo la parte di codice che si occupa della gestione dell'interfaccia HTTP, usando gli strumenti di introsprezione del codice offerti dal linguaggio come i decoratori.
            Esso \'e stato scelto perch\'e l'applicazione, essendo destinata all'uso interno, non necessitava di gestioni di rete di basso livello.
            L'attenzione principale \'e stata invece posta sulla riusabilità dell'API.

    \section{Interazione con i sistemi di controllo di versione}           
        Tutte le azioni effettuate dal report sono operazioni sul file system che vengono successivamente registrate in un sistema di controllo di versione.
        Il risultato delle azioni performate vengono salvate in un area di stage (o pre-commit).
        Questo rende le operazioni completamente reversibili e le modifiche non vengono rese effettive fino a quando non viene creato un commit e viene revisionato.\\
        Una specifica del report \'e poter usare sia \textbf{Git} e \textbf{Svn (Subversion)} in modo trasparente allo sviluppatore.
        Questo per facilitare una migrazione futura delle suite di test da Subversion a Git.
            
    \section{Struttura dell'API}
        TODO:
    
    \section{Bundling dell'applicazione e deploy}
        TODO: Spiegare come l'ho messo sul server

        In produzione l'applicazione serve l'API e il frontend sulla stessa porta.
        La SPA è stata compilata in una cartella di file statici, (quali html e javascript) in modo che essi possano essere serviti dall'applicazione senza usare un server di debug separato.
        Per rendere disponibili le due parti dell'applicazioni sotto lo stesso indirizzo è stato modificato il metodo di risoluzione delle sottochiamate
        Gli indirizzi che iniziano con \textit{v1/} contengono le chiamate dell'API.
        i rimanenti si occupano di servire il frontend, e son stati a loro volta suddivisi:
        I file statici (detti assets) e le route della Single Page Application.
        Se il percorso coincide con file presente nella cartella \textit{static} esso viene servito trammite HTTP.
        Altrimenti viene esposta la single page application, servendo il file html, che reindirizzerà l'utente sulla pagina richiesta o segnalerà un errore se la route è invalida o inesistente.